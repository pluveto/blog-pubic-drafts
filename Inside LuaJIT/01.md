---
title: 理解 LuaJIT：一个简单程序的执行过程
title-en: Inside LuaJIT: The load and execution of a simple program.
---

LuaJIT 是 Lua 语言的一个高性能实现，它包含一个即时编译器（JIT，Just-In-Time Compiler），能够将 Lua 代码高效地转换为本地机器代码以提高执行速度。

本文通过一个简单的例子，介绍 LuaJIT 的非 JIT 模式执行过程。

假设你已经有了 LuaJIT2 的源代码，我们需要准备一个 *tests/hello.lua* 文件。包含以下代码：

```lua
print("hello, world!")
```

本文将通过讲述它的完整一生，让读者对 LuaJIT 的机制和基础数据结构以及函数有所概念。

## 命令行解析和程序初始化

本阶段的调用栈概览

pmain
   handle_script
       luaL_loadfile/luaL_loadfilex
           lua_loadx
               lj_vm_cpcall/cpparser
                   lj_lex_setup init lexer state
                       lj_parse
                           parse_chunk
                               parse_stmt

### 解析命令行参数

当你在命令行中输入 `luajit hello.lua` 时，操作系统会解析这个命令。操作系统会查找名为 "luajit" 的可执行文件（在你的PATH环境变量中），并将 "hello.lua" 作为参数传递给它。因此 luajit 的 `main` 函数（位于 `src/luajit.c` 中）会被调用。

在 `main` 中，程序会创建 `lua_State`，表示一个 Lua 状态机。（还会保存 `argc`, `argv` 到全局静态变量 `smain`。）

然后，程序会通过 `lua_cpcall` 间接调用 `pmain` 函数（位于 `src/lua.c` 中）。这是为了保证在 `pmain` 函数中发生的错误能够被捕获。

### Lua 状态机

Lua 状态机(Lua State)表示一个 Lua 环境(environment)。每个状态机都有自己的全局环境(global environment)和栈(stack)。
当我们引入 Lua 库并创建 Lua 环境后,就会得到一个 Lua 状态机。我们可以在该状态机上执行 Lua 代码,访问全局变量和函数,操作栈等。
一个 Lua 状态机包含以下主要数据:

- 全局环境: 包含全局变量和函数
- 栈: Lua 使用栈来传递参数值和接收结果
- 其他环境: coroutine 和闭包 的环境
- 错误处理器: responsible for handling errors
- GC 数据: 用来标记可以被 GC 的对象
当我们要执行多段独立的 Lua 代码时,需要创建多个独立的 Lua 状态机,每个状态机有自己的环境和栈。

### 将命令行参数交给 Lua

在 pmain 中，我们通过 `collectargs` 对命令行参数进行基本的解析，例如用户输入 `-v`，则加上 flag `FLAGS_VERSION`。然后根据 flag 的设置不同，会有不同的行为，例如 `FLAGS_VERSION` 存在，则打印版本信息。

由于我们的参数是一个文件名，pcall 将调用 `handle_script`，在 `handle_script` 中，我们调用 `luaL_loadfile`，从而将文件内容加载到 Lua 状态机中。

`luaL_loadfile` 内部会调用 `luaL_loadfilex`，我们进入到文件的装载流程。

## 装载和解析文件

### 文件的装载

相关代码在 `src/lj_load.c` 中。

`luaL_loadfilex` 直接通过 `fopen` 打开文件，还会把文件名记录到状态栈，作为 `chunkname`。文件打开后，文件描述符保存在 ctx 中。ctx 指的是 `FileReaderCtx`，它可以作为读取文件的缓冲，并记录读到了哪里。

然后 luaL_loadfilex 调用 lua_loadx。这里面，利用 lj_vm_cpcall 调用 cpparser。

在 cpparser 中，主要目标是：

1. 进行词法分析（利用 LexState）
2. GCproto 生成（通过解析字节码或者源代码）
   前者使用 `lj_bcread`
   后者使用 `lj_parse`
3. 生成 GCfunc

实际上，整个 chunk 最后会被转换为一个 GCfunc，然后放到状态机的栈顶。由于我们的源码是文本格式，所以会调用 `lj_parse`。

### 代码的解析

解析相关代码在 `src/lj_parse.c` 中。

LuaJIT 的解析过程中，词法分析和语法分析是一起进行的，这一点从函数原型也可以看出来：

```c
GCproto *lj_parse(LexState *ls)
```

解析的目的是生成 GCproto，一个函数原型。与 GCfunc 不同，GCproto 只包含函数的原型信息，而不包含函数的运行时状态。比如说，upvalue 的值就不包含在 GCproto 中。

一些解析时比较重要的信息保存在 ls（LexState）中，例如 fs（FuncState）、tok（当前 Token）、行号和文件名等。

> FuncState 通过 fs_init 初始化，它包含了当前函数的许多信息，为编译和执行该函数提供支持。例如 bl 当前作用域、prev 外围函数状态、bcbase 字节码栈的基地址、pc 指针等。其中 bcbase 能告诉我们下一条字节码插入到哪里。

当预先读取一个 token 之后，就进入到 parse_chunk 函数中。

```c
 lj_lex_next(ls);  /* Read-ahead first token. */
 parse_chunk(ls);
```

lua 中的 chunk 是一个语句块，它可以包含多个语句。函数定义、变量定义、表达式等都是语句。因此函数体可以看做是一个语句块。甚至整个文件也可以看做是一个语句块。

parse_chunk 函数会不断尝试调用 parse_stmt，直到所有的语句都被解析完毕。parse_stmt 会根据下一个 Token，调用其构成元素的解析器，例如 parse_func、parse_if、parse_while 等。

这是一种经典的递归下降解析流程。

由于我们的代码是一个函数调用，所以 parse_chunk 会调用 parse_call_assign。然后 `print("hello world")` 会被解析为一个表达式。

### 解析表达式

本例的表达式在 expr_primary 函数中被解析。

在解析技术中，表达式可以分为前缀（prefix）、中缀（infix）、后缀（postfix）和基础（primary）四个部分。

例如：`-10! + (9! + 8!)` 这个数学表达式中，`-` 是前缀，`!` 是后缀，`+` 是中缀，`10`、`9`、`8` 是基础。我们也可以把 `(9! + 8!)` 看做一个基础。

一个更复杂的例子：`a.b.c[1].d(1, 2, 3)`。它可以看做基础 `a.b.c[1].d` 和后缀 `(1, 2, 3)` 两部分，整体上构成一个 CallExpr。前缀是一个 MemberExpr，后者是一个 ArgList。`a.b.c[1].d` 又可以分为两部分：

- `a.b.c[1]` 是一个 MemberExpr，它的前缀是 `a.b.c`，后缀是 `[1]`。
- `d` 是一个 PrimaryExpr，它同时也是 `.` Op 的 RHS Opr。

expr_primary 它能够处理诸如变量、函数调用、表索引和方法调用等表达式。它只支持前缀表达式和后缀表达式的解析。

原始代码有些复杂，这里不写出来了。只给一个简化的伪代码：

```lua
function parse_primary_expression(ls, v)
 -- Parse prefix expression
 parse_prefix_expression(ls, v)

 -- Parse multiple expression suffixes in a loop
 while true do
   if ls.tok is field_access, table_index, method_call, or function_call then
     parse_expression_suffix(ls, v)
   else
     break
   end
 end
end
```

对于中缀表达式，它是利用文法规则的层次化来实现对优先级的处理的。

## 字节码的生成

LuaJIT 解析器非常紧凑，解析的同时也生成字节码。对于我们的程序，首先调用 `var_lookup` 在作用域中搜索被调用的函数，存放到 ExpDesc 的状态中。然后，调用 `parse_args` 解析参数列表。

在这过程中，参数相关的字节码被生成。例如我们的参数是字符串，则会经过 `parse_args -> expr_list -> expr_binop -> expr_unop -> expr_simple` 的流程。在 `expr_init` 中，会调用 `emit_kstr` 生成字节码。

最后调用 `BCINS_ABC` 生成字节码，通过 `bcemit_INS` 将字节码推入字节码栈。

## 执行 Lua 代码

解析完成之后，字节码也生成了。我们回到 cpparser，一个新的函数已经创建好，并被放置在 lua_State 的栈顶。

然后我们回到 handle_script，Lua 通过调用 docall 执行这些字节码。do_call 中，程序会设置跟踪函数。base 错误处理函数的位置，然后调用 lua_pcall 开始执行。

lua_pcall 中，通过 lj_vm_pcall 开始在虚拟机执行 Lua 函数。被执行的函数的地址通过 `api_call_base(L, nargs)` 推算出。（因为 Lua 中，每个参数的长度都是固定的，因此可以通过参数的数量推算出函数的地址）
lua_pcall 会调用函数并捕获错误。

lj_vm_pcall 是用来执行一个 Lua 函数并返回其结果或错误信息的虚拟机入口函数。

lj_vm_pcall 的源码并不是 C 语言写的。它是通过 DynASM 生成的汇编代码。你可以在 dasc 文件中搜索 `->vm_pcall` 找到它的定义。

它会设置被保护的 C 栈帧，顺序执行后进入 vm_call_dispatch。然后视情况决定是否跳转到 `lj_vmeta_call`（比如函数对象存在元方法）

我们的情况下，会继续顺序执行，进入 `lj_vm_call_dispatch_f`，然后跳转到 `lj_BC_IFUNCV`。`lj_BC_IFUNCV` 指令的操作数是内部函数（且是 C 函数）的索引，它将该内部函数的索引压入堆栈，并将堆栈顶部的值作为函数的参数。然后，它调用该内部函数，并将其返回值放回堆栈中。其中，IFUNC 表示“内部函数”，V表示“可变参数列表”（variadic arguments）。

然后，它进入 `lj_BC_GGET`、`lj_BC_TGETS` 获取被调函数的参数（一个 KSTR）。

然后进入 `lj_BC_CALL`，然后进入 `lj_BC_FUNCC`，调用内部函数 `lj_cf_print`，完成打印。

之后，进入 `lj_vm_returnc`，执行 `lj_BC_RET`，`lj_BC_RET0`，返回。返回到 `lj_vm_return` `lj_vm_leave_unw`，`lj_vm_leave_cp`，最后完成 pcall.

## 分发表和计算跳转

那么 LuaJIT 如何知道不同指令如何执行呢？它使用了 dispatch table 和 computed gotos 技术。这种技术非常容易理解

解释器中通常会使用两种方法来处理控制流：计算跳转（computed gotos）和传统写法（如switch语句）。下面是一个非常简单的C语言例子，演示了两种方法在解释器中的应用以及它们的优缺点。

首先，我们假设有一个虚拟机，执行四个操作：加、减、乘、除。指令集如下：

```c
enum Opcode {
   OP_ADD = 0,
   OP_SUB,
   OP_MUL,
   OP_DIV,
   OP_LENGTH
};
```

传统的写法就是循环套 Switch

```c
void interpret_switch(int *stack, int *program, int program_size) {
   for (int ip = 0; ip < program_size; ++ip) {
       int op = program[ip];
       int a = stack[0];
       int b = stack[1];

       switch (op) {
           case OP_ADD:
               stack[0] = a + b;
               break;
           case OP_SUB:
               stack[0] = a - b;
               break;
           case OP_MUL:
               stack[0] = a * b;
               break;
           case OP_DIV:
               stack[0] = a / b;
               break;
       }
   }
}

```

而计算跳转的写法如下：

```c
#define DISPATCH() goto *labels[program[ip++]]

void interpret_computed_goto(int *stack, int *program, int program_size) {
   static void* labels[] = {&&op_add, &&op_sub, &&op_mul, &&op_div};

   int ip = 0;

   DISPATCH();

   op_add:
       stack[0] = stack[0] + stack[1];
       DISPATCH();

   op_sub:
       stack[0] = stack[0] - stack[1];
       DISPATCH();

   op_mul:
       stack[0] = stack[0] * stack[1];
       DISPATCH();

   op_div:
       stack[0] = stack[0] / stack[1];
       DISPATCH();
}
#undef DISPATCH
```

除了让代码更加紧凑外，计算跳转的最大优势是性能上的提升。计算跳转使用goto语句直接跳转到目标代码位置，跳转目标固定的，使得分支预测器容易预测下一条指令。switch语句通常会被编译成条件跳转指令，预测成功率相对较低。除此之外，计算跳转还可以手动进行一些特殊内联，例如直接指定一个指令的下一条指令处理逻辑的位置。

上面的例子中的 labels 就是一个分发表。

在 LuaJIT 中，分发表定义在 `GG_State` 的 dispatch 字段。在 lua_newstate 时，会调用 `lj_dispatch_init` 初始化分发表以及热计数器。我们结合源码分析。

```c
/* Initialize instruction dispatch table and hot counters. */
void lj_dispatch_init(GG_State *GG)
{
 uint32_t i;
 ASMFunction *disp = GG->dispatch;
 for (i = 0; i < GG_LEN_SDISP; i++)
   disp[GG_LEN_DDISP+i] = disp[i] = makeasmfunc(lj_bc_ofs[i]);
 for (i = GG_LEN_SDISP; i < GG_LEN_DDISP; i++)
   disp[i] = makeasmfunc(lj_bc_ofs[i]);
 /* The JIT engine is off by default. luaopen_jit() turns it on. */
 disp[BC_FORL] = disp[BC_IFORL];
 disp[BC_ITERL] = disp[BC_IITERL];
 /* Workaround for stable v2.1 bytecode. TODO: Replace with BC_IITERN. */
 disp[BC_ITERN] = &lj_vm_IITERN;
 disp[BC_LOOP] = disp[BC_ILOOP];
 disp[BC_FUNCF] = disp[BC_IFUNCF];
 disp[BC_FUNCV] = disp[BC_IFUNCV];
 GG->g.bc_cfunc_ext = GG->g.bc_cfunc_int = BCINS_AD(BC_FUNCC, LUA_MINSTACK, 0);
 for (i = 0; i < GG_NUM_ASMFF; i++)
   GG->bcff[i] = BCINS_AD(BC__MAX+i, 0, 0);
}
```

disp 即是分发表，可以看做一个映射，从指令字节码指向汇编函数（ASMFunction）函数。这里的循环就是初始化分发表的主要逻辑，makeasmfunc 将LuaJIT内部的字节码指令偏移转换为实际的汇编函数指针。

我们还会看到 `disp[BC_FORL] = disp[BC_IFORL];` 这样的代码，这是设置某些特定字节码的分发指针。将BC_FORL字节码的分发指针设置为与BC_IFORL相同，后者是BC_FORL的内联版本。

```c
GG->g.bc_cfunc_ext = GG->g.bc_cfunc_int = BCINS_AD(BC_FUNCC, LUA_MINSTACK, 0);
```

这行初始化了全局状态的内部和外部C函数调用的默认字节码。它们将BC_FUNCC字节码与给定的参数A（LUA_MINSTACK）和参数D（0）一起编码成一个32位整数，用于在分发表中查找分发指针。GG->g.bc_cfunc_ext 和 GG->g.bc_cfunc_int 这两个字段表示内部和外部C函数调用的默认字节码。这意味着当LuaJIT需要调用C函数时，将使用这个字节码作为默认行为。

```c
 for (i = 0; i < GG_NUM_ASMFF; i++)
   GG->bcff[i] = BCINS_AD(BC__MAX+i, 0, 0);
```

初始化了LuaJIT的所有内联汇编快速函数（Asm Fast Functions，简称ASMFF）的字节码。

作的一组高效汇编函数。这些函数可以在运行时直接内嵌到字节码指令流中，从而提高执行性能。LuaJIT通过将这些函数直接内嵌到字节码流中，避免了额外的函数调用开销，使得这些特定操作的执行更加高效。

一个快速函数的例子是 lj_vm_modi，它采用 dasc 编写：

```dasc
 |  // int lj_vm_modi(int dividend, int divisor);
 |->vm_modi:
 |    eor CARG4w, CARG1w, CARG2w
 |    cmp CARG4w, #0
 |  eor CARG3w, CARG1w, CARG1w, asr #31
 |   eor CARG4w, CARG2w, CARG2w, asr #31
 |  sub CARG3w, CARG3w, CARG1w, asr #31
 |   sub CARG4w, CARG4w, CARG2w, asr #31
 |  udiv CARG1w, CARG3w, CARG4w
 |  msub CARG1w, CARG1w, CARG4w, CARG3w
 |    ccmp CARG1w, #0, #4, mi
 |    sub CARG3w, CARG1w, CARG4w
 |    csel CARG1w, CARG1w, CARG3w, eq
 |  eor CARG3w, CARG1w, CARG2w
 |  cmp CARG3w, #0
 |  cneg CARG1w, CARG1w, mi
 |  ret
```

按照 Mike 的说法，我们可以找到一个这样的宏：

```dasc
|// Instruction decode+dispatch. Carefully tuned (nope, lodsd is not faster).
|.macro ins_NEXT
|  mov RCd, [PC]
|  movzx RAd, RCH
|  movzx OP, RCL
|  add PC, 4
|  shr RCd, 16
|  jmp aword [DISPATCH+OP*8]
|.endmacro
```

这里将PC寄存器指向的内存中的指令读取出来，然后将指令解码出操作码 OP，根据 OP 计算下一条指令的地址。

每个指令结尾都会执行 ins_next，从而实现了字节码指令之间的跳转，不需要一个低效率的 switch + 主循环。

而第一条指令的地址是通过 vm_call 设置，从而程序一开始直接从对应位置开始执行。

## JIT 编译

在执行过程中，LuaJIT 的即时编译器会观察代码的运行情况。如果发现某些代码片段频繁执行，他们就会被编译成 IR，然后可以基于 IR 优化并生成机器码。

然而，在这个简单的例子中，我们的代码只有一行，且只执行一次，尽管 JIT 可能会初始化，但不会触发 JIT 编译。我们先跳过。

## GC

执行完毕之后，lua_close 会释放 lua_State，这个过程会进行 GC。由于代码只有一行，内存占用率很低，所以执行过程中不太可能触发 GC。我们这次跳过这个部分。

## 参考

https://eli.thegreenplace.net/2012/07/12/computed-goto-for-efficient-dispatch-tables

LuaJIT 2.x (not out yet) uses a different VM. The bytecode has an 8
bit opcode field and 2 or 3 operands with 8/8/8 or 8/16 bits. The
interpreter is written in hand-coded assembler. Dispatch is
decentralized at the end of every operation using an indirect jump
through a central table, indexed by the opcode. The dispatch table
can be patched on-the-fly to support debugging and trace recording.

http://lua-users.org/lists/lua-l/2008-07/msg00651.html


